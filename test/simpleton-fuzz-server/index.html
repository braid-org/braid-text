<meta charset="utf-8">
<style></style>
<body style="margin: 0; padding: 20px; font-family: monospace; box-sizing: border-box; height: 100vh; overflow: hidden; display: flex; flex-direction: column">
  <div style="margin-bottom: 12px; display: flex; gap: 32px">
    <div>
      <div style="margin-bottom: 8px">
        <b style="font-size: 14px">Simpleton Fuzz Tester</b>
      </div>
      <div style="display: flex; flex-direction: column; gap: 3px; font-size: 12px; color: #444">
        <label><input id="session_duration" type="number" style="width:65px"> ms session duration</label>
        <label><input id="settle_delay" type="number" style="width:65px"> ms settle delay</label>
        <label><input id="edit_interval_min" type="number" style="width:65px">–<input id="edit_interval_max" type="number" style="width:65px"> ms edit interval</label>
        <label><input id="min_delay" type="number" style="width:65px">–<input id="max_delay" type="number" style="width:65px"> ms ACK delay</label>
        <label><input id="connect_min" type="number" style="width:65px">–<input id="connect_max" type="number" style="width:65px"> ms connected duration</label>
        <label><input id="disconnect_min" type="number" style="width:65px">–<input id="disconnect_max" type="number" style="width:65px"> ms disconnected duration</label>
        <label><input id="put_drop_prob" type="number" step="1" min="0" max="100" style="width:65px">% PUT drop probability</label>
        <label><input id="ack_drop_prob" type="number" step="1" min="0" max="100" style="width:65px">% ACK drop probability</label>
      </div>
    </div>
    <div style="font-size: 12px; color: #444; border-left: 1px solid #ddd; padding-left: 20px; max-width: 520px">
      <b style="color: #222">Connecting a Simpleton Client</b>
      <ol style="margin: 6px 0 0; padding-left: 18px; line-height: 1.8">
        <li>Subscribe to <code>/fuzz-session</code> (GET with <code>Subscribe</code> header). Optionally set a <code>Peer</code> header to name your client.</li>
        <li>Server sends <code>{"type":"start", "peer":"…", "doc_key":"/fuzz-doc-…"}</code>. Use <code>doc_key</code> to connect your simpleton-sync client.</li>
        <li>Server sends edit commands to simulate local user typing. Apply them to your document and call <code>changed()</code>:
          <div style="margin: 3px 0; line-height: 1.4">
            <code>{"type":"edit", "range":[5,5], "content":"a"}</code> (insert)<br>
            <code>{"type":"edit", "range":[3,5], "content":""}</code> (delete)<br>
            <code>{"type":"edit", "range":[3,5], "content":"x"}</code> (replace)
          </div>
          <code>range</code> is <code>[start, end]</code> in the text. Clamp both to your actual text length.
        </li>
        <li>Server also makes remote edits (via PUT) which arrive through the normal simpleton-sync subscription. These updates include a <code>Repr-Digest</code> header (SHA-256). Your client should verify that the digest matches your document state after applying patches — throw/crash on mismatch (don't try to recover).</li>
        <li>When you receive <code>{"type":"upload-state"}</code>, POST your final document text to <code>/fuzz-session</code> as <code>{"type":"state", "peer":"…", "state":"…"}</code>. Server compares it to expected state.</li>
      </ol>
      <p style="margin: 6px 0 0; color: #888"><a href="/test" target="_blank">/test</a> runs this protocol using the JS reference implementation of simpleton-sync.</p>
    </div>
  </div>
  <div id="error_banner" style="display: none; background: #f44; color: white; padding: 6px; margin-bottom: 8px; font-weight: bold; border-radius: 4px"></div>
  <div id="session_list" style="flex: 1; overflow: auto">
    <p style="color: #888; margin-top: 0">Waiting for test clients to connect to <a href="/test" target="_blank">/test</a>...</p>
  </div>
</body>
<script src="/braid-http-client.js"></script>
<script src="/simpleton-sync.js"></script>
<script src="/web-utils.js"></script>
<script>

  var error_count = 0
  var peer_bars = {}      // peer -> { el, progress, status_dot, status_label, detail, result }
  var connected_peers = new Set()

  function show_error(msg) {
    error_count++
    error_banner.style.display = "block"
    error_banner.textContent = `ERRORS: ${error_count} -- latest: ${msg}`
  }

  // ── Per-session bar management ──────────────────────────────────────────

  function get_or_create_bar(peer_id) {
    if (peer_bars[peer_id]) return peer_bars[peer_id]

    // Clear the "waiting" message on first bar
    if (Object.keys(peer_bars).length === 0) session_list.innerHTML = ""

    var bar = document.createElement("div")
    bar.style.cssText = "margin-bottom: 6px; border: 1px solid #ccc; border-radius: 4px; overflow: hidden; background: #fafafa"

    // Header row: dot + peer ID + status label + result badge
    var header = document.createElement("div")
    header.style.cssText = "display: flex; align-items: center; padding: 6px 10px; gap: 8px; font-size: 12px; cursor: pointer"

    var dot = document.createElement("span")
    dot.style.cssText = "width: 8px; height: 8px; border-radius: 50%; background: #ccc; flex-shrink: 0"

    var name = document.createElement("span")
    name.style.cssText = "font-weight: bold; flex-shrink: 0"
    name.textContent = peer_id

    var status_label = document.createElement("span")
    status_label.style.cssText = "color: #888; font-size: 11px; flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap"

    var result_badge = document.createElement("span")
    result_badge.style.cssText = "font-weight: bold; font-size: 11px; padding: 1px 6px; border-radius: 3px; flex-shrink: 0; display: none"

    header.appendChild(dot)
    header.appendChild(name)
    header.appendChild(status_label)
    header.appendChild(result_badge)

    // Progress bar (no transition initially — enabled after first position set)
    var progress_wrap = document.createElement("div")
    progress_wrap.style.cssText = "height: 3px; background: #eee"
    var progress_fill = document.createElement("div")
    progress_fill.style.cssText = "height: 100%; width: 0%; background: #0a0"
    progress_wrap.appendChild(progress_fill)

    // Collapsible detail (for results)
    var detail = document.createElement("div")
    detail.style.cssText = "display: none; padding: 6px 10px; font-size: 11px; border-top: 1px solid #eee; background: #f5f5f5"

    header.onclick = () => {
      if (detail.children.length > 0)
        detail.style.display = detail.style.display === "none" ? "block" : "none"
    }

    bar.appendChild(header)
    bar.appendChild(progress_wrap)
    bar.appendChild(detail)

    // Most recent at top
    session_list.prepend(bar)

    var entry = { el: bar, progress: progress_fill, progress_wrap, status_dot: dot, status_label, result_badge, detail, result: null, fresh: true }
    peer_bars[peer_id] = entry
    return entry
  }

  function update_bar_connection(peer_id, is_connected) {
    var b = get_or_create_bar(peer_id)
    if (is_connected) {
      b.status_dot.style.background = "#0a0"
      if (!b.result) b.status_label.textContent = "connected"
    } else {
      b.status_dot.style.background = "#ccc"
      if (!b.result) b.status_label.textContent = "disconnected"
    }
  }

  function update_bar_progress(peer_id, sd, cfg) {
    var b = peer_bars[peer_id]
    if (!b || b.result) return  // don't update progress after result

    // Show disconnect state in the dot
    if (sd.disconnected) {
      b.status_dot.style.background = "#f80"
    } else {
      b.status_dot.style.background = "#0a0"
    }

    if (sd.running && sd.start_time) {
      var elapsed = Date.now() - sd.start_time
      var pct = Math.min(100, (elapsed / cfg.session_duration) * 100)
      b.progress.style.width = pct + "%"
      b.progress.style.background = "#0a0"
      b.progress.style.animation = ""
      var remaining = Math.max(0, Math.ceil((cfg.session_duration - elapsed) / 1000))
      var status = `fuzzing — ${remaining}s remaining`
      if (sd.disconnected) status += " (disconnected)"
      b.status_label.textContent = status
      // Enable smooth transition after first position is set
      if (b.fresh) {
        b.fresh = false
        requestAnimationFrame(() => { b.progress.style.transition = "width 0.4s linear" })
      }
    } else if (sd.settling) {
      if (b.fresh) { b.fresh = false }
      b.progress.style.animation = ""
      b.progress.style.background = "#07f"
      if (sd.settle_start_time) {
        var settle_elapsed = Date.now() - sd.settle_start_time
        var settle_pct = Math.min(100, (settle_elapsed / cfg.settle_delay) * 100)
        b.progress.style.transition = "width 0.25s linear"
        b.progress.style.width = settle_pct + "%"
        var settle_remaining = Math.max(0, Math.ceil((cfg.settle_delay - settle_elapsed) / 1000))
        b.status_label.textContent = `settling — ${settle_remaining}s remaining`
      } else {
        b.progress.style.transition = ""
        b.progress.style.width = "0%"
        b.status_label.textContent = sd.pending_acks > 0
          ? `waiting for ${sd.pending_acks} ACK${sd.pending_acks > 1 ? "s" : ""}...`
          : "settling..."
      }
      if (sd.disconnected) b.status_label.textContent += " (disconnected)"
    }
  }

  function set_bar_result(peer_id, result) {
    var b = get_or_create_bar(peer_id)
    b.result = result

    if (result.match) {
      b.result_badge.textContent = "PASS"
      b.result_badge.style.background = "#0a0"
      b.result_badge.style.color = "white"
      b.el.style.borderColor = "#0a0"
      b.progress.style.background = "#0a0"
      b.status_label.textContent = "passed"
    } else {
      b.result_badge.textContent = "FAIL"
      b.result_badge.style.background = "#f44"
      b.result_badge.style.color = "white"
      b.el.style.borderColor = "#f44"
      b.progress.style.background = "#f44"
      b.status_label.textContent = `failed (server: ${result.server_state.length}, client: ${result.client_state.length} chars)`
    }
    b.result_badge.style.display = "inline"
    b.progress.style.width = "100%"
    b.progress.style.animation = ""

    // Populate detail
    b.detail.innerHTML = ""

    var label1 = document.createElement("div")
    label1.style.cssText = "margin-bottom: 2px; color: #666"
    label1.textContent = result.match ? "Server state:" : "Server state (expected):"
    b.detail.appendChild(label1)

    var ta1 = document.createElement("textarea")
    ta1.readOnly = true
    ta1.value = result.server_state
    ta1.style.cssText = "width: 100%; height: 60px; font-family: monospace; font-size: 11px; resize: vertical; box-sizing: border-box; margin-bottom: 4px"
    b.detail.appendChild(ta1)

    if (!result.match) {
      var label2 = document.createElement("div")
      label2.style.cssText = "margin-bottom: 2px; color: #666"
      label2.textContent = "Client state (actual):"
      b.detail.appendChild(label2)

      var ta2 = document.createElement("textarea")
      ta2.readOnly = true
      ta2.value = result.client_state
      ta2.style.cssText = "width: 100%; height: 60px; font-family: monospace; font-size: 11px; resize: vertical; box-sizing: border-box"
      b.detail.appendChild(ta2)

      // Auto-expand on failure
      b.detail.style.display = "block"
    }

  }

  // ── Subscribe to fuzz results ─────────────────────────────────────────
  braid_fetch("/fuzz-results", {
    subscribe: true,
    retry: () => true
  }).then(res => {
    res.subscribe(update => {
      try {
        var result = JSON.parse(update.body_text)
        set_bar_result(result.peer, result)
      } catch (e) {
        console.error("result parse error:", e)
      }
    })
  })

  // ── Subscribe to config/session state ────────────────────────────────
  var config_loaded = false

  braid_fetch("/config", {
    subscribe: true,
    retry: () => true
  }).then(res => {
    res.subscribe(update => {
      try {
        var cfg = JSON.parse(update.body_text)
        // Populate input fields on first update
        if (!config_loaded) {
          config_loaded = true
          min_delay.value = cfg.min_delay
          max_delay.value = cfg.max_delay
          edit_interval_min.value = cfg.edit_interval_min
          edit_interval_max.value = cfg.edit_interval_max
          session_duration.value = cfg.session_duration
          settle_delay.value = cfg.settle_delay
          connect_min.value = cfg.connect_min
          connect_max.value = cfg.connect_max
          disconnect_min.value = cfg.disconnect_min
          disconnect_max.value = cfg.disconnect_max
          put_drop_prob.value = Math.round(cfg.put_drop_prob * 100)
          ack_drop_prob.value = Math.round(cfg.ack_drop_prob * 100)
        }
        update_from_config(cfg)
      } catch (e) {
        console.error("config parse error:", e)
      }
    })
  })

  var config_inputs = [min_delay, max_delay, edit_interval_min, edit_interval_max, session_duration, settle_delay, connect_min, connect_max, disconnect_min, disconnect_max, put_drop_prob, ack_drop_prob]
  config_inputs.forEach(el => el.onchange = send_config)

  function send_config() {
    fetch("/config", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        min_delay: parseInt(min_delay.value),
        max_delay: parseInt(max_delay.value),
        edit_interval_min: parseInt(edit_interval_min.value),
        edit_interval_max: parseInt(edit_interval_max.value),
        session_duration: parseInt(session_duration.value),
        settle_delay: parseInt(settle_delay.value),
        connect_min: parseInt(connect_min.value),
        connect_max: parseInt(connect_max.value),
        disconnect_min: parseInt(disconnect_min.value),
        disconnect_max: parseInt(disconnect_max.value),
        put_drop_prob: parseFloat(put_drop_prob.value) / 100,
        ack_drop_prob: parseFloat(ack_drop_prob.value) / 100
      })
    })
  }

  function update_from_config(cfg) {
    // Track which peers are currently connected
    var details = cfg.session_details || []
    var current_peers = new Set(details.map(s => s.peer))

    // Create/update bars for connected peers
    for (var sd of details) {
      update_bar_connection(sd.peer, true)
      update_bar_progress(sd.peer, sd, cfg)
    }

    // Mark disconnected peers
    for (var peer of connected_peers) {
      if (!current_peers.has(peer)) {
        update_bar_connection(peer, false)
      }
    }

    connected_peers = current_peers

    // Show waiting message if no peers ever connected
    if (Object.keys(peer_bars).length === 0 && cfg.sessions === 0) {
      session_list.innerHTML = '<p style="color: #888; margin-top: 0">Waiting for test clients to connect to <a href="/test" target="_blank">/test</a>...</p>'
    }
  }

</script>
